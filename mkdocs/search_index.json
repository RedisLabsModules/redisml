{
    "docs": [
        {
            "location": "/", 
            "text": "Machine Learning Model Server on Redis\n\n\nRedis-ML is a Redis module that implements several machine learning models as Redis data types.\n\n\nThe stored models are fully operational and support performing the prediction/evaluation.\n\n\nRedis-ML is a turn key solution for using trained models in a production environment. Allowing loading ML models from any platform immediately ready to serve.\n\n\nThe module includes these primary features:\n\n\n\n\nDecision Tree ensembles (random forests) classification and regression\n\n\nLinear regression\n\n\nLogistic regression\n\n\nMatrix operations\n\n\n\n\nBuilding and running\n\n\n\n\n\n\nBuild a Redis server with support for modules (currently available from the\u00a0\nunstable branch\n).\n\n\n\n\n\n\nYou'll also need a \nBLAS\n library, for example \nATLAS\n. To install ATLAS:\n\n\n\n\n\n\nUbuntu:\u00a0\nsudo apt-get install libatlas-base-dev\n\n\n\n\n\n\nCentOS/RHEL/Fedora:\u00a0\nsudo yum install atlas-devel\n\n\n\n\n\n\nBuild the Redis-ML module:\n\n\n\n\n\n\nsh\n  git clone https://github.com/RedisLabsModules/redis-ml.git\n  cd redis-ml/src\n  make\n\n\n\n\nTo load the module, start Redis with the\u00a0\n--loadmodule /path/to/redis-ml/src/redis-ml.so\n\u00a0option, add it as a directive to the configuration file or send a\u00a0\nMODULE LOAD\n\u00a0command.\n\n\n\n\nContributing\n\n\nIssue reports, pull and feature requests are welcome.\n\n\nLicense\n\n\nAGPLv3 - see\u00a0\nLICENSE", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#machine-learning-model-server-on-redis", 
            "text": "Redis-ML is a Redis module that implements several machine learning models as Redis data types.  The stored models are fully operational and support performing the prediction/evaluation.  Redis-ML is a turn key solution for using trained models in a production environment. Allowing loading ML models from any platform immediately ready to serve.  The module includes these primary features:   Decision Tree ensembles (random forests) classification and regression  Linear regression  Logistic regression  Matrix operations", 
            "title": "Machine Learning Model Server on Redis"
        }, 
        {
            "location": "/#building-and-running", 
            "text": "Build a Redis server with support for modules (currently available from the\u00a0 unstable branch ).    You'll also need a  BLAS  library, for example  ATLAS . To install ATLAS:    Ubuntu:\u00a0 sudo apt-get install libatlas-base-dev    CentOS/RHEL/Fedora:\u00a0 sudo yum install atlas-devel    Build the Redis-ML module:    sh\n  git clone https://github.com/RedisLabsModules/redis-ml.git\n  cd redis-ml/src\n  make   To load the module, start Redis with the\u00a0 --loadmodule /path/to/redis-ml/src/redis-ml.so \u00a0option, add it as a directive to the configuration file or send a\u00a0 MODULE LOAD \u00a0command.", 
            "title": "Building and running"
        }, 
        {
            "location": "/#contributing", 
            "text": "Issue reports, pull and feature requests are welcome.", 
            "title": "Contributing"
        }, 
        {
            "location": "/#license", 
            "text": "AGPLv3 - see\u00a0 LICENSE", 
            "title": "License"
        }, 
        {
            "location": "/commands/", 
            "text": "Redis ML Commands\n\n\nDecision tree ensembles\n\n\nExample of use\n\n\nThe following creates a \nrandom forest\n under the key \nmyforest\n that consists of three trees with ids ranging from 0 to 2, where each consists of a single numeric splitter and its predicate values. Afterwards, the forest is used to classify two inputs and yield their predictions.\n\n\nredis\n ML.FOREST.ADD myforst 0 . NUMERIC 1 0.1 .l LEAF 1 .r LEAF 0\nOK\nredis\n ML.FOREST.ADD myforst 1 . NUMERIC 1 0.1 .l LEAF 1 .r LEAF 0\nOK\nredis\n ML.FOREST.ADD myforst 2 . NUMERIC 1 0.1 .l LEAF 0 .r LEAF 1\nOK\nredis\n ML.FOREST.RUN myforst 1:0.01 CLASSIFICATION\n\n1\n\nredis\n ML.FOREST.RUN myforst 1:0.2 CLASSIFICATION\n\n0\n\n\n\n\n\nML.FOREST.ADD\n\n\n\n\nAvailable since 1.0.0.\n\n\nTime complexity:\n O(M*log(N)) where N is the tree's depth and M is the number of nodes added\n\n\n\n\nSyntax\n\n\nML.FOREST.ADD key tree path ((NUMERIC|CATEGORIC) attr val | LEAF val [STATS]) [...]\n\n\n\n\nDescription\n\n\nAdd nodes to a tree in the forest.\nThis command adds one or more nodes to the tree in the forest that's stored under \nkey\n. Trees are identified by numeric ids, \ntreeid\n, that must begin at 0 and incremented by exactly 1 for each new tree. \n\n\nEach of the nodes is described by its path and definition. The \npath\n argument is the path from the tree's root to the node. A valid path always starts with the period character (\n.\n), which denotes the root. Optionally, the root may be followed by left or right branches ,denoted by the characters \nl\n and \nr\n, respectively. For example, the path \n\".lr\"\n refers to the right child of the root's left child.\n\n\nA node in the decision tree can either be a splitter or a terminal leaf.  Splitter nodes are either numerical or categorical, and are added using the \nNUMERIC\n or \nCATEGORIC\n keywords. Splitter nodes also require specifying the examined attribute (\nattr\n) as well as the value (\nval\n) used in the comparison made during the branching decision. \nval\n is expected to be a double-precision floating point value for numerical splitters, and a string for categorical splitter nodes.\n\n\nThe leaves are created with the \nLEAF\n keyword and only require specifying their double-precision floating point value (\nval\n).\n\n\nReturn value:\n\n\nSimple string reply\n\n\nML.FOREST.RUN\n\n\n\n\nAvailable since 1.0.0.\n\n\nTime complexity:\n O(M*log(N)) where N is the depth of the trees and M is the number of trees in the forest\n\n\n\n\nSyntax\n\n\nML.FOREST.RUN key sample (CLASSIFICATION|REGRESSION)\n\n\n\n\nDescription\n\n\nPredicts the classified (discrete) or regressed (continuous) value of a sample using the forest.\nThe forest that's stored in \nkey\n is used for generating the predicted value for the \nsample\n. The sample is given as a string that is a vector of attribute-value pairs in the format of \nattr:val\n. For example,  the \nsample\n \n\"gender:male\"\n has a single attribute, \ngender\n, whose value is \nmale\n. A sample may have multiple such attribute-value pairs, and these must be comma-separated (\n,\n) in the string vector. For example, a sample of a 25 years old male is expressed as \n\"gender:male,age:25\"\n.\n\n\nReturn value:\n\n\nBulk string reply: the predicted value of the sample\n\n\nLinear regression\n\n\nExample of use\n\n\nThe first line of the example shows how a linear regression predictor is set to the key named \nlinear\n. The predictor has an intercept of 2 and its coefficients are 3, 4 and 5. Once the predicator is ready, it is used to predict the result given the independent variables' values (features) of 1, 1 and 1.\n\n\nredis\n ML.LINREG.SET linear 2 3 4 5\nOK\nredis\n ML.LINREG.PREDICT linear 1 1 1\n\n14\n\n\n\n\n\nML.LINREG.SET\n\n\n\n\nAvailable since 1.0.0.\n\n\nTime complexity:\n O(N) where N is the number of coefficients\n\n\n\n\nSyntax\n\n\nML.LINREG.SET key intercept coefficient [...]\n\n\n\n\nDescription\n\n\nSets a linear regression predictor.\nThis command creates or updates the linear regression predictor that's stored in \nkey\n. The predictor's intercept is specified by  \nintercept\n, followed by one or more \ncoefficient\n arguments of the independent variables.\n\n\nReturn value:\n\n\nSimple string reply\n\n\nML.LINREG.PREDICT\n\n\n\n\nAvailable since 1.0.0.\n\n\nTime complexity:\n O(N) where N is the number features\n\n\n\n\nSyntax\n\n\nML.LINREG.PREDICT key feature [...]\n\n\n\n\nDescription\n\n\nPredicts the result for a set of features.\nThe linear regression predictor stored in \nkey\n is used for predicting the result based on one or more features that are given by the \nfeature\n argument(s).\n\n\nReturn value:\n\n\nBulk string reply: the predicted result for the feature set\n\n\nLogistic regression\n\n\nExample of use\n\n\nIn this example, the first line shows how a logistic regression predictor is set to the key named \nlogistic\n. The predictor has an intercept of 0 and its coefficients are 2 and 2. Once the predicator is ready, it is used to predict the result given the independent variables' values (features) of -3 and 1.\n\n\nredis\n ML.LOGREG.SET logistic 0 2 2\nOK\nredis\n ML.LOGREG.PREDICT logistic -3 1\n\n0.017986209962091559\n\n\n\n\n\nML.LOGREG.SET\n\n\n\n\nAvailable since 1.0.0.\n\n\nTime complexity:\n O(N) where N is the number of coefficients\n\n\n\n\nSyntax\n\n\nML.LOGREG.SET key intercept coefficient [...]\n\n\n\n\nDescription\n\n\nSets a linear regression predictor.\nThis command sets or updates the logistic regression predictor that's stored in \nkey\n. The predictor's intercept is specified by  \nintercept\n, followed by one or more \ncoefficient\n arguments of the independent variables.\n\n\nReturn value:\n\n\nSimple string reply\n\n\nML.LOGREG.PREDICT\n\n\n\n\nAvailable since 1.0.0.\n\n\nTime complexity:\n O(N) where N is the number features\n\n\n\n\nSyntax\n\n\nML.LOGREG.PREDICT key feature [...]\n\n\n\n\nDescription\n\n\nPredicts the result for a set of features.\nThe logistic regression predictor stored in \nkey\n is used for predicting the result based on one or more features that are given by the \nfeature\n argument(s).\n\n\nReturn value:\n\n\nBulk string reply: the predicted result for the feature set\n\n\nMatrix operations\n\n\nExample of use\n\n\nThe following example shows how to set two matrices, \na\n and \nb\n, and then multiply them storing the result in the matrix \nab\n. Lastly, the contents of \nab\n are fetched.\n\n\nredis\n ML.MATRIX.SET a 2 3 1 2 5 3 4 6\nOK\nredis\n ML.MATRIX.SET b 3 2 1 2 3 4 7 1\nOK\nredis\n ML.MATRIX.MULTIPLY a b ab\nOK\nredis\n ML.MATRIX.GET ab\n1) (integer) 2\n2) (integer) 2\n3) \n42\n\n4) \n15\n\n5) \n57\n\n6) \n28\n\n\n\n\n\nML.MATRIX.SET\n\n\n\n\nAvailable since 1.0.0.\n\n\nTime complexity:\n O(N*M) where N is the number of rows and M is the number of columns\n\n\n\n\nSyntax\n\n\nML.MATRIX.SET key n m entry11 .. entrynm\n\n\n\n\nDescription\n\n\nSets a matrix.\nSets \nkey\n to store a matrix of  \nn\n rows,\nm\n columns and double-precision float entries ranging from \nentry11\n to \nentrynm\n.\n\n\nReturn value:\n\n\nSimple string reply\n\n\nML.MATRIX.GET\n\n\n\n\nAvailable since 1.0.0.\n\n\nTime complexity:\n O(N*M) where N is the number of rows and M is the number of columns\n\n\n\n\nSyntax\n\n\nML.MATRIX.GET key\n\n\n\n\nDescription\n\n\nGet a matrix.\nReturns the matrix's dimensions and entries.\n\n\nReturn value:\n\n\nArray reply. The first two elements are the matrix's rows and columns, respectively, followed by the entries.\n\n\nML.MATRIX.ADD\n\n\n\n\nAvailable since 1.0.0.\n\n\nTime complexity:\n O(N*M) where N is the number of rows and M is the number of columns\n\n\n\n\nSyntax\n\n\nML.MATRIX.ADD matrix1 matrix2 sum\n\n\n\n\nDescription\n\n\nAdds matrices.\nThe result of adding the two matrices stored in \nmatrix1\n and \nmatrix2\n is set in \nsum\n.\n\n\nReturn value:\n\n\nSimple string reply\n\n\nML.MATRIX.MULTIPLY\n\n\n\n\nAvailable since 1.0.0.\n\n\nTime complexity:\n O(N*M*P) where N and M are numbers of rows and columns in \nmatrix1\n, and P is the number of columns in \nmatrix2\n\n\n\n\nSyntax\n\n\nML.MATRIX.MULTIPLY matrix1 matrix2 product\n\n\n\n\nDescription\n\n\nMultiplies matrices.\nThe result of multiplying the two matrices stored in \nmatrix1\n and \nmatrix2\n is set in \nproduct\n.\n\n\nReturn value:\n\n\nSimple string reply\n\n\nML.MATRIX.SCALE\n\n\n\n\nAvailable since 1.0.0.\n\n\nTime complexity:\n O(N*M) where N is the number of rows and M is the number of columns\n\n\n\n\nSyntax\n\n\nML.MATRIX.SCALE key scalar\n\n\n\n\nDescription\n\n\nScales a matrix.\nUpdates the entries of the matrix stored in \nkey\n by multiplying them with \nscalar\n.\n\n\nReturn value:\n\n\nSimple string reply", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#redis-ml-commands", 
            "text": "", 
            "title": "Redis ML Commands"
        }, 
        {
            "location": "/commands/#decision-tree-ensembles", 
            "text": "", 
            "title": "Decision tree ensembles"
        }, 
        {
            "location": "/commands/#example-of-use", 
            "text": "The following creates a  random forest  under the key  myforest  that consists of three trees with ids ranging from 0 to 2, where each consists of a single numeric splitter and its predicate values. Afterwards, the forest is used to classify two inputs and yield their predictions.  redis  ML.FOREST.ADD myforst 0 . NUMERIC 1 0.1 .l LEAF 1 .r LEAF 0\nOK\nredis  ML.FOREST.ADD myforst 1 . NUMERIC 1 0.1 .l LEAF 1 .r LEAF 0\nOK\nredis  ML.FOREST.ADD myforst 2 . NUMERIC 1 0.1 .l LEAF 0 .r LEAF 1\nOK\nredis  ML.FOREST.RUN myforst 1:0.01 CLASSIFICATION 1 \nredis  ML.FOREST.RUN myforst 1:0.2 CLASSIFICATION 0", 
            "title": "Example of use"
        }, 
        {
            "location": "/commands/#mlforestadd", 
            "text": "Available since 1.0.0.  Time complexity:  O(M*log(N)) where N is the tree's depth and M is the number of nodes added", 
            "title": "ML.FOREST.ADD"
        }, 
        {
            "location": "/commands/#syntax", 
            "text": "ML.FOREST.ADD key tree path ((NUMERIC|CATEGORIC) attr val | LEAF val [STATS]) [...]", 
            "title": "Syntax"
        }, 
        {
            "location": "/commands/#description", 
            "text": "Add nodes to a tree in the forest.\nThis command adds one or more nodes to the tree in the forest that's stored under  key . Trees are identified by numeric ids,  treeid , that must begin at 0 and incremented by exactly 1 for each new tree.   Each of the nodes is described by its path and definition. The  path  argument is the path from the tree's root to the node. A valid path always starts with the period character ( . ), which denotes the root. Optionally, the root may be followed by left or right branches ,denoted by the characters  l  and  r , respectively. For example, the path  \".lr\"  refers to the right child of the root's left child.  A node in the decision tree can either be a splitter or a terminal leaf.  Splitter nodes are either numerical or categorical, and are added using the  NUMERIC  or  CATEGORIC  keywords. Splitter nodes also require specifying the examined attribute ( attr ) as well as the value ( val ) used in the comparison made during the branching decision.  val  is expected to be a double-precision floating point value for numerical splitters, and a string for categorical splitter nodes.  The leaves are created with the  LEAF  keyword and only require specifying their double-precision floating point value ( val ).", 
            "title": "Description"
        }, 
        {
            "location": "/commands/#return-value", 
            "text": "Simple string reply", 
            "title": "Return value:"
        }, 
        {
            "location": "/commands/#mlforestrun", 
            "text": "Available since 1.0.0.  Time complexity:  O(M*log(N)) where N is the depth of the trees and M is the number of trees in the forest", 
            "title": "ML.FOREST.RUN"
        }, 
        {
            "location": "/commands/#syntax_1", 
            "text": "ML.FOREST.RUN key sample (CLASSIFICATION|REGRESSION)", 
            "title": "Syntax"
        }, 
        {
            "location": "/commands/#description_1", 
            "text": "Predicts the classified (discrete) or regressed (continuous) value of a sample using the forest.\nThe forest that's stored in  key  is used for generating the predicted value for the  sample . The sample is given as a string that is a vector of attribute-value pairs in the format of  attr:val . For example,  the  sample   \"gender:male\"  has a single attribute,  gender , whose value is  male . A sample may have multiple such attribute-value pairs, and these must be comma-separated ( , ) in the string vector. For example, a sample of a 25 years old male is expressed as  \"gender:male,age:25\" .", 
            "title": "Description"
        }, 
        {
            "location": "/commands/#return-value_1", 
            "text": "Bulk string reply: the predicted value of the sample", 
            "title": "Return value:"
        }, 
        {
            "location": "/commands/#linear-regression", 
            "text": "", 
            "title": "Linear regression"
        }, 
        {
            "location": "/commands/#example-of-use_1", 
            "text": "The first line of the example shows how a linear regression predictor is set to the key named  linear . The predictor has an intercept of 2 and its coefficients are 3, 4 and 5. Once the predicator is ready, it is used to predict the result given the independent variables' values (features) of 1, 1 and 1.  redis  ML.LINREG.SET linear 2 3 4 5\nOK\nredis  ML.LINREG.PREDICT linear 1 1 1 14", 
            "title": "Example of use"
        }, 
        {
            "location": "/commands/#mllinregset", 
            "text": "Available since 1.0.0.  Time complexity:  O(N) where N is the number of coefficients", 
            "title": "ML.LINREG.SET"
        }, 
        {
            "location": "/commands/#syntax_2", 
            "text": "ML.LINREG.SET key intercept coefficient [...]", 
            "title": "Syntax"
        }, 
        {
            "location": "/commands/#description_2", 
            "text": "Sets a linear regression predictor.\nThis command creates or updates the linear regression predictor that's stored in  key . The predictor's intercept is specified by   intercept , followed by one or more  coefficient  arguments of the independent variables.", 
            "title": "Description"
        }, 
        {
            "location": "/commands/#return-value_2", 
            "text": "Simple string reply", 
            "title": "Return value:"
        }, 
        {
            "location": "/commands/#mllinregpredict", 
            "text": "Available since 1.0.0.  Time complexity:  O(N) where N is the number features", 
            "title": "ML.LINREG.PREDICT"
        }, 
        {
            "location": "/commands/#syntax_3", 
            "text": "ML.LINREG.PREDICT key feature [...]", 
            "title": "Syntax"
        }, 
        {
            "location": "/commands/#description_3", 
            "text": "Predicts the result for a set of features.\nThe linear regression predictor stored in  key  is used for predicting the result based on one or more features that are given by the  feature  argument(s).", 
            "title": "Description"
        }, 
        {
            "location": "/commands/#return-value_3", 
            "text": "Bulk string reply: the predicted result for the feature set", 
            "title": "Return value:"
        }, 
        {
            "location": "/commands/#logistic-regression", 
            "text": "", 
            "title": "Logistic regression"
        }, 
        {
            "location": "/commands/#example-of-use_2", 
            "text": "In this example, the first line shows how a logistic regression predictor is set to the key named  logistic . The predictor has an intercept of 0 and its coefficients are 2 and 2. Once the predicator is ready, it is used to predict the result given the independent variables' values (features) of -3 and 1.  redis  ML.LOGREG.SET logistic 0 2 2\nOK\nredis  ML.LOGREG.PREDICT logistic -3 1 0.017986209962091559", 
            "title": "Example of use"
        }, 
        {
            "location": "/commands/#mllogregset", 
            "text": "Available since 1.0.0.  Time complexity:  O(N) where N is the number of coefficients", 
            "title": "ML.LOGREG.SET"
        }, 
        {
            "location": "/commands/#syntax_4", 
            "text": "ML.LOGREG.SET key intercept coefficient [...]", 
            "title": "Syntax"
        }, 
        {
            "location": "/commands/#description_4", 
            "text": "Sets a linear regression predictor.\nThis command sets or updates the logistic regression predictor that's stored in  key . The predictor's intercept is specified by   intercept , followed by one or more  coefficient  arguments of the independent variables.", 
            "title": "Description"
        }, 
        {
            "location": "/commands/#return-value_4", 
            "text": "Simple string reply", 
            "title": "Return value:"
        }, 
        {
            "location": "/commands/#mllogregpredict", 
            "text": "Available since 1.0.0.  Time complexity:  O(N) where N is the number features", 
            "title": "ML.LOGREG.PREDICT"
        }, 
        {
            "location": "/commands/#syntax_5", 
            "text": "ML.LOGREG.PREDICT key feature [...]", 
            "title": "Syntax"
        }, 
        {
            "location": "/commands/#description_5", 
            "text": "Predicts the result for a set of features.\nThe logistic regression predictor stored in  key  is used for predicting the result based on one or more features that are given by the  feature  argument(s).", 
            "title": "Description"
        }, 
        {
            "location": "/commands/#return-value_5", 
            "text": "Bulk string reply: the predicted result for the feature set", 
            "title": "Return value:"
        }, 
        {
            "location": "/commands/#matrix-operations", 
            "text": "", 
            "title": "Matrix operations"
        }, 
        {
            "location": "/commands/#example-of-use_3", 
            "text": "The following example shows how to set two matrices,  a  and  b , and then multiply them storing the result in the matrix  ab . Lastly, the contents of  ab  are fetched.  redis  ML.MATRIX.SET a 2 3 1 2 5 3 4 6\nOK\nredis  ML.MATRIX.SET b 3 2 1 2 3 4 7 1\nOK\nredis  ML.MATRIX.MULTIPLY a b ab\nOK\nredis  ML.MATRIX.GET ab\n1) (integer) 2\n2) (integer) 2\n3)  42 \n4)  15 \n5)  57 \n6)  28", 
            "title": "Example of use"
        }, 
        {
            "location": "/commands/#mlmatrixset", 
            "text": "Available since 1.0.0.  Time complexity:  O(N*M) where N is the number of rows and M is the number of columns", 
            "title": "ML.MATRIX.SET"
        }, 
        {
            "location": "/commands/#syntax_6", 
            "text": "ML.MATRIX.SET key n m entry11 .. entrynm", 
            "title": "Syntax"
        }, 
        {
            "location": "/commands/#description_6", 
            "text": "Sets a matrix.\nSets  key  to store a matrix of   n  rows, m  columns and double-precision float entries ranging from  entry11  to  entrynm .", 
            "title": "Description"
        }, 
        {
            "location": "/commands/#return-value_6", 
            "text": "Simple string reply", 
            "title": "Return value:"
        }, 
        {
            "location": "/commands/#mlmatrixget", 
            "text": "Available since 1.0.0.  Time complexity:  O(N*M) where N is the number of rows and M is the number of columns", 
            "title": "ML.MATRIX.GET"
        }, 
        {
            "location": "/commands/#syntax_7", 
            "text": "ML.MATRIX.GET key", 
            "title": "Syntax"
        }, 
        {
            "location": "/commands/#description_7", 
            "text": "Get a matrix.\nReturns the matrix's dimensions and entries.", 
            "title": "Description"
        }, 
        {
            "location": "/commands/#return-value_7", 
            "text": "Array reply. The first two elements are the matrix's rows and columns, respectively, followed by the entries.", 
            "title": "Return value:"
        }, 
        {
            "location": "/commands/#mlmatrixadd", 
            "text": "Available since 1.0.0.  Time complexity:  O(N*M) where N is the number of rows and M is the number of columns", 
            "title": "ML.MATRIX.ADD"
        }, 
        {
            "location": "/commands/#syntax_8", 
            "text": "ML.MATRIX.ADD matrix1 matrix2 sum", 
            "title": "Syntax"
        }, 
        {
            "location": "/commands/#description_8", 
            "text": "Adds matrices.\nThe result of adding the two matrices stored in  matrix1  and  matrix2  is set in  sum .", 
            "title": "Description"
        }, 
        {
            "location": "/commands/#return-value_8", 
            "text": "Simple string reply", 
            "title": "Return value:"
        }, 
        {
            "location": "/commands/#mlmatrixmultiply", 
            "text": "Available since 1.0.0.  Time complexity:  O(N*M*P) where N and M are numbers of rows and columns in  matrix1 , and P is the number of columns in  matrix2", 
            "title": "ML.MATRIX.MULTIPLY"
        }, 
        {
            "location": "/commands/#syntax_9", 
            "text": "ML.MATRIX.MULTIPLY matrix1 matrix2 product", 
            "title": "Syntax"
        }, 
        {
            "location": "/commands/#description_9", 
            "text": "Multiplies matrices.\nThe result of multiplying the two matrices stored in  matrix1  and  matrix2  is set in  product .", 
            "title": "Description"
        }, 
        {
            "location": "/commands/#return-value_9", 
            "text": "Simple string reply", 
            "title": "Return value:"
        }, 
        {
            "location": "/commands/#mlmatrixscale", 
            "text": "Available since 1.0.0.  Time complexity:  O(N*M) where N is the number of rows and M is the number of columns", 
            "title": "ML.MATRIX.SCALE"
        }, 
        {
            "location": "/commands/#syntax_10", 
            "text": "ML.MATRIX.SCALE key scalar", 
            "title": "Syntax"
        }, 
        {
            "location": "/commands/#description_10", 
            "text": "Scales a matrix.\nUpdates the entries of the matrix stored in  key  by multiplying them with  scalar .", 
            "title": "Description"
        }, 
        {
            "location": "/commands/#return-value_10", 
            "text": "Simple string reply", 
            "title": "Return value:"
        }
    ]
}